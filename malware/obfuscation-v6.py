# POLYMORPHIC OBFUSCATION DEMONSTRATION
# Polymorphic code maintains the same functionality but changes its appearance
# on each execution through techniques like:
# - Dynamic encoding/encryption
# - Variable implementation patterns
# - Runtime code generation

import random
import base64
import sys
import time
from threading import Timer

# Polymorphic technique 1: String obfuscation functions
def poly_encode(s, key=None):
    """Polymorphic string encoding that uses different methods based on runtime conditions"""
    if key is None:
        key = random.randint(1, 10)
    
    # Choose encoding method based on random key
    method = key % 3
    
    if method == 0:
        # XOR encoding
        return ''.join(chr(ord(c) ^ key) for c in s)
    elif method == 1:
        # Base64 encoding with a twist
        return base64.b64encode(s.encode()).decode()[::-1]  # Reversed base64
    else:
        # Character shift encoding
        return ''.join(chr((ord(c) + key) % 256) for c in s)

def poly_decode(s, key, method=None):
    """Decode a polymorphically encoded string"""
    if method is None:
        method = key % 3
    
    if method == 0:
        # XOR decoding
        return ''.join(chr(ord(c) ^ key) for c in s)
    elif method == 1:
        # Reverse and base64 decode
        return base64.b64decode(s[::-1].encode()).decode()
    else:
        # Character shift decoding
        return ''.join(chr((ord(c) - key) % 256) for c in s)

# Polymorphic technique 2: File writing with polymorphic behavior
def write_to_file(content):
    """
    Writes content to a file using polymorphic techniques
    The implementation changes with each run
    """
    # Choose a random implementation pattern at runtime
    pattern = random.randint(1, 3)
    
    if pattern == 1:
        # Standard approach
        try:
            with open(".\\attack.txt", 'a', encoding='utf-8') as file:
                file.write(content)
        except IOError as ioException:
            print(f"Error writing to file: {ioException}", file=sys.stderr)
        except Exception as exception:
            print(f"Unexpected error: {exception}", file=sys.stderr)
    elif pattern == 2:
        # Different error handling approach
        file_obj = None
        try:
            file_obj = open(".\\attack.txt", 'a', encoding='utf-8')
            file_obj.write(content)
        except Exception as ex:
            print(f"Operation failed: {ex}", file=sys.stderr)
        finally:
            if file_obj is not None:
                file_obj.close()
    else:
        # Binary mode approach
        try:
            with open(".\\attack.txt", 'ab') as file:
                file.write(content.encode('utf-8'))
        except Exception as ex:
            print(f"Failed: {ex}", file=sys.stderr)
# Polymorphic technique 3: Main execution with variable behavior patterns
if __name__ == "__main__":
    print("----------------------------- Polymorphic Obfuscation Test Sample -----------------------------")
    
    # Polymorphic technique 4: Runtime string encoding with multiple implementations
    # The EICAR string is encoded differently in each execution path
    
    # Original EICAR test string
    eicar_original = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
    
    # Choose a random encoding key for this execution
    encoding_key = random.randint(1, 10)
    
    # Encode the EICAR string differently based on runtime conditions
    encoded_eicar = poly_encode(eicar_original, encoding_key)
    
    # Polymorphic technique 5: Variable control flow patterns
    # Randomly choose between different loop implementations
    loop_type = random.randint(1, 3)
    
    if loop_type == 1:
        # Standard for loop implementation
        for index in range(10):
            time.sleep(0.100)
            
            if index == 5:
                # Decode the string at runtime
                eicar = poly_decode(encoded_eicar, encoding_key)
                print(eicar)
                write_to_file(eicar)
                break
                
    elif loop_type == 2:
        # While loop implementation
        index = 0
        while index < 10:
            time.sleep(0.100)
            
            if index == 5:
                # Split the encoded string and join it at runtime
                parts = [encoded_eicar[i:i+len(encoded_eicar)//3] for i in range(0, len(encoded_eicar), len(encoded_eicar)//3)]
                reassembled = ''.join(parts)
                
                # Decode the reassembled string
                eicar = poly_decode(reassembled, encoding_key)
                print(eicar)
                write_to_file(eicar)
                break
                
            index += 1
    else:
        # Recursive implementation
        def process_index(idx):
            if idx >= 10:
                return
                
            time.sleep(0.100)
            
            if idx == 5:
                # Use a different approach to decode
                eicar = poly_decode(encoded_eicar, encoding_key)
                print(eicar)
                write_to_file(eicar)
                return
                
            process_index(idx + 1)
            
        # Start the recursive process
        process_index(0)
        
    print("------------------------------------------------------------------------------------")