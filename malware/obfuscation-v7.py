# METAMORPHIC OBFUSCATION DEMONSTRATION
# Unlike polymorphic code which just changes appearance, metamorphic code
# completely rewrites and restructures itself on each execution while
# maintaining the same functionality.
#
# Key characteristics of metamorphic obfuscation:
# 1. Code rewriting - entire program structure changes
# 2. Instruction substitution - using functionally equivalent but different code
# 3. Register/variable reassignment - variables change names and locations
# 4. Code transposition - operations order changes while preserving logic
# 5. Subroutine permutation - functions get rewritten and reorganized

import sys
import time
import random
import base64
import re

# The metamorphic engine that rebuilds the program on each run
class MetamorphicEngine:
    def __init__(self):
        # Store our metamorphic code blocks
        self.code_blocks = {}
        
        # Generate random identifiers for this instance
        self.variable_names = self._generate_variable_names()
        
        # Build our code patterns for this execution
        self._init_code_patterns()
    
    def _generate_variable_names(self):
        """Generate random variable names for this execution instance"""
        var_names = {}
        # List of variables we need to rename
        base_vars = ['file', 'content', 'eicar', 'index', 'result', 'error']
        
        for var in base_vars:
            # Create a random variable name (2-3 random words combined)
            name_length = random.randint(5, 12)
            name = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(name_length))
            var_names[var] = name
            
        return var_names
    
    def _init_code_patterns(self):
        """Initialize different code patterns for metamorphic behavior"""
        # Different ways to implement file writing
        self.code_blocks['file_writing'] = [
            # Implementation 1: Standard approach
            f"""
            def {self.variable_names['file']}_write({self.variable_names['content']}):
                with open(".\\\\attack.txt", 'a', encoding='utf-8') as {self.variable_names['file']}:
                    {self.variable_names['file']}.write({self.variable_names['content']})
                return True
            """,
            # Implementation 2: Using binary mode
            f"""
            def {self.variable_names['file']}_operation({self.variable_names['content']}):
                with open(".\\\\attack.txt", 'ab') as {self.variable_names['file']}_handler:
                    {self.variable_names['file']}_handler.write({self.variable_names['content']}.encode('utf-8'))
                return True
            """,
            # Implementation 3: Low-level approach
            f"""
            def append_data_to_file({self.variable_names['content']}):
                {self.variable_names['file']}_obj = open(".\\\\attack.txt", 'a')
                try:
                    {self.variable_names['file']}_obj.write({self.variable_names['content']})
                finally:
                    {self.variable_names['file']}_obj.close()
                return True
            """
        ]
        
        # Different ways to implement error handling
        self.code_blocks['error_handling'] = [
            # Implementation 1: Simple try-except
            f"""
            def safe_execute(func, *args):
                try:
                    return func(*args)
                except Exception as {self.variable_names['error']}:
                    print(f"Error: {{{self.variable_names['error']}}}", file=sys.stderr)
                    return False
            """,
            # Implementation 2: Using a context manager
            f"""
            class ErrorContext:
                def __enter__(self):
                    return self
                def __exit__(self, exc_type, exc_val, exc_tb):
                    if exc_val:
                        print(f"Error: {{exc_val}}", file=sys.stderr)
                    return True
                    
            def execute_with_error_handling(func, *args):
                with ErrorContext():
                    return func(*args)
            """
        ]
        
        # Different ways to store and process the EICAR string
        self.code_blocks['eicar_processing'] = [
            # Implementation 1: Direct string with base64 encoding
            f"""
            {self.variable_names['eicar']} = "X5O!P%@AP[4\\\\PZX54(P^)7CC)7}}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
            {self.variable_names['result']} = base64.b64encode({self.variable_names['eicar']}.encode()).decode()
            {self.variable_names['eicar']} = base64.b64decode({self.variable_names['result']}.encode()).decode()
            """,
            # Implementation 2: Split and join approach
            f"""
            {self.variable_names['eicar']}_parts = ["X5O!P%@AP[4\\\\P", "ZX54(P^)7CC)7}}$", "EICAR-STANDARD-", "ANTIVIRUS-TEST-FILE!$H+H*"]
            {self.variable_names['eicar']} = ""
            for part in {self.variable_names['eicar']}_parts:
                {self.variable_names['eicar']} += part
            """,
            # Implementation 3: Character substitution approach
            f"""
            {self.variable_names['eicar']}_encoded = "Y6P\"Q&AP\\5]QAY65)Q_*8DD*8~%FJDBS.TUBOEBSE.BOUJWJSVT.UFTU.GJMF\"%I,I+"
            {self.variable_names['eicar']} = ""
            for c in {self.variable_names['eicar']}_encoded:
                {self.variable_names['eicar']} += chr(ord(c) - 1)
            """
        ]
        
        # Different loop implementations
        self.code_blocks['loop_implementations'] = [
            # Implementation 1: For loop
            f"""
            for {self.variable_names['index']} in range(10):
                time.sleep(0.1)
                if {self.variable_names['index']} == 5:
                    print({self.variable_names['eicar']})
                    write_func({self.variable_names['eicar']})
                    break
            """,
            # Implementation 2: While loop
            f"""
            {self.variable_names['index']} = 0
            while {self.variable_names['index']} < 10:
                time.sleep(0.1)
                if {self.variable_names['index']} == 5:
                    print({self.variable_names['eicar']})
                    write_func({self.variable_names['eicar']})
                    break
                {self.variable_names['index']} += 1
            """,
            # Implementation 3: Recursive approach
            f"""
            def process_{self.variable_names['index']}(n):
                if n >= 10:
                    return
                time.sleep(0.1)
                if n == 5:
                    print({self.variable_names['eicar']})
                    write_func({self.variable_names['eicar']})
                    return
                return process_{self.variable_names['index']}(n + 1)
            
            process_{self.variable_names['index']}(0)
            """
        ]
    
    def get_morphed_code(self):
        """Generate completely different code structure with each run"""
        # Choose a random implementation for each code block
        file_write_impl = random.choice(self.code_blocks['file_writing'])
        error_handling_impl = random.choice(self.code_blocks['error_handling'])
        eicar_impl = random.choice(self.code_blocks['eicar_processing'])
        loop_impl = random.choice(self.code_blocks['loop_implementations'])
        
        # Create a unique function name for this execution
        write_func_name = f"write_func"
        
        # Randomly decide code block ordering - completely restructuring the code
        code_structure = [
            "# Metamorphically generated code - structure changes with each execution",
            error_handling_impl,
            file_write_impl,
            f"# Map the write function to a consistent name for the loop implementation",
            f"write_func = {write_func_name}" if write_func_name in file_write_impl else 
              (f"write_func = {self.variable_names['file']}_write" if f"{self.variable_names['file']}_write" in file_write_impl else
              (f"write_func = {self.variable_names['file']}_operation" if f"{self.variable_names['file']}_operation" in file_write_impl else
               "write_func = append_data_to_file")),
            eicar_impl,
            "# The core execution logic also morphs with each run",
            loop_impl
        ]
        
        # Add some randomized junk code to further confuse analysis
        junk_code = [
            f"# This comment will change position and content each time",
            f"{random.choice(['x', 'y', 'temp', 'data'])} = {random.randint(1, 100)} # Meaningless variable",
            f"if {random.randint(0, 1)} == {random.randint(2, 3)}: print('This will never execute')",
            f"try: int('x' * {random.randint(1, 10)})\nexcept: pass # Error that always occurs but is suppressed",
        ]
        
        # Insert junk code at random positions
        for junk in junk_code:
            position = random.randint(0, len(code_structure))
            code_structure.insert(position, junk)
            
        # Join all code blocks with proper indentation
        return '\n'.join(code_structure)
# Execute the metamorphic code
if __name__ == "__main__":
    print("----------------------------- Metamorphic Obfuscation Test Sample -----------------------------")
    
    # Create the metamorphic engine
    engine = MetamorphicEngine()
    
    # Generate completely new code structure
    morphed_code = engine.get_morphed_code()
    
    # Execute the metamorphic code (completely different in each run)
    try:
        # Create a namespace for execution
        namespace = {'sys': sys, 'time': time, 'random': random, 'base64': base64}
        
        # Execute the morphed code
        exec(morphed_code, namespace)
    except Exception as e:
        print(f"Error in metamorphic code execution: {e}")
    
    print("------------------------------------------------------------------------------------")