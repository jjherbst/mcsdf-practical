import random
import string
import os

class metamorphic_engine:
    def __init__(self, base_filename="metamorphic-virus-", version_file="version.txt"):
        self.base_filename = base_filename
        self.version_file = version_file
        self.version = self.load_version()

    def load_version(self):
        # Check for existing files to determine the next version
        if os.path.exists(self.version_file):
            with open(self.version_file, 'r') as f:
                try:
                    return int(f.read().strip()) + 1
                except ValueError:
                    pass
        # If no version file, find the highest existing version
        import glob
        files = glob.glob(f"{self.base_filename}-*.py")
        versions = [int(f.split('-')[-1].replace('.py', '')) for f in files if f.split('-')[-1].replace('.py', '').isdigit()]
        return max(versions, default=0) + 1

    def save_version(self):
        with open(self.version_file, 'w') as f:
            f.write(str(self.version))

    def random_var(self):
        return ''.join(random.choices(string.ascii_lowercase, k=random.randint(4, 8)))

    def junk_line(self):
        """Generate a completely safe junk line at module level"""
        var = self.random_var()
        return f"{var} = None"

    def insert_junk(self, code_lines):
        """Insert junk code only between function/class definitions at module level"""
        new_code = []
        can_insert_junk = True
        in_function = False
        in_class = False
        prev_was_empty = False
        
        for line in code_lines:
            stripped = line.strip()
            
            # Handle empty lines
            if not stripped:
                new_code.append(line)
                prev_was_empty = True
                continue
                
            # Check for start/end of functions and classes
            if stripped.startswith('def '):
                in_function = True
                can_insert_junk = False
            elif stripped.startswith('class '):
                in_class = True
                can_insert_junk = False
            elif not line.startswith(' ') and (in_function or in_class):
                in_function = False
                in_class = False
                can_insert_junk = True
            
            # Only insert junk at module level between functions/classes
            # and only after an empty line
            if (can_insert_junk and prev_was_empty and 
                not any(stripped.startswith(x) for x in [
                    'import ', 'from ', '#', '@', 'def ', 'class ', 
                    'if ', 'else:', 'elif ', 'try:', 'except:', 'finally:',
                    'while ', 'for ', 'with ', 'return ', 'raise ', 'print('])
                and random.random() < 0.1):
                new_code.append(self.junk_line())
                
            new_code.append(line)
            prev_was_empty = False
            
        return new_code

    def mutate_code(self, logic_blocks):
        # Shuffle independent blocks
        random.shuffle(logic_blocks["constants"])
        random.shuffle(logic_blocks["functions"])

        # Assemble with junk
        final_code = logic_blocks["imports"][:]
        final_code = self.insert_junk(final_code)

        for block in logic_blocks["constants"]:
            final_code.extend(self.insert_junk(block.splitlines()))

        for block in logic_blocks["functions"]:
            final_code.extend(self.insert_junk(block.splitlines()))

        final_code.extend(self.insert_junk(logic_blocks["main"].splitlines()))

        final_code.extend(self.insert_junk(logic_blocks["entry"].splitlines()))

        # Update file_name in main to current version
        final_code = [line.replace("obfuscation-v7.bin", f"obfuscation-v7-{self.version}.bin") if "file_name =" in line else line for line in final_code]

        return '\n'.join(final_code)

    def generate_variant(self, logic_blocks):
        new_code = self.mutate_code(logic_blocks)
        filename = f"{self.base_filename}-{self.version}.py"
        with open(filename, 'w') as f:
            f.write(new_code)
        print(f"Generated {filename}")
        self.save_version()
        return filename

def get_logic_blocks():
    # Hardcoded logic blocks from obfuscation-v7.py
    logic_blocks = {
        "imports": [
            "#!/usr/bin/env python3",
            "",
            "import sys",
            "import time",
            "import base64",
            "import gzip",
            "import socket",
            "import os",
            "import secrets",
            "import base64",
            "import hashlib",
            "from io import BytesIO",
            "from pathlib import Path",
            "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC",
            ""
        ],
        "constants": [
            "# === suspicious API calls (benign, not executed) =================================================\n" +
            "SUSPICIOUS_API_CALLS = [\n" +
            "    base64.b64decode(b'VmlydHVhbEFsbG9j').decode(),\n" +
            "    base64.b64decode(b'V3JpdGVQcm9jZXNzTWVtb3J5').decode(),\n" +
            "    base64.b64decode(b'Q3JlYXRlUmVtb3RlVGhyZWFk').decode(),\n" +
            "    base64.b64decode(b'U2V0V2luZG93c0hvb2tFeA==').decode(),\n" +
            "    base64.b64decode(b'RmluZFdpbmRvdw==').decode(),\n" +
            "    base64.b64decode(b'R2V0UHJvY0FkZHJlc3M=').decode(),\n" +
            "    base64.b64decode(b'TG9hZExpYnJhcnk=').decode(),\n" +
            "    base64.b64decode(b'UmVnU2V0VmFsdWVFeA==').decode(),\n" +
            "    base64.b64decode(b'U2hlbGxFeGVjdXRl').decode(),\n" +
            "    base64.b64decode(b'VmlydHVhbEFsbG9jRXg=').decode(),\n" +
            "    base64.b64decode(b'Q3JlYXRlUmVtb3RlVGhyZWFk').decode(),\n" +
            "    base64.b64decode(b'V3JpdGVQcm9jZXNzTWVtb3J5').decode(),\n" +
            "    base64.b64decode(b'V2luRXhlYw==').decode(),\n" +
            "    base64.b64decode(b'TnRRdWVyeUluZm9ybWF0aW9uUHJvY2Vzcw==').decode(),\n" +
            "    base64.b64decode(b'QWRqdXN0VG9rZW5Qcml2aWxlZ2Vz').decode(),\n" +
            "    base64.b64decode(b'TG9hZExpYnJhcnlB').decode(),\n" +
            "    base64.b64decode(b'R2V0UHJvY0FkZHJlc3M=').decode(),\n" +
            "    base64.b64decode(b'Q3J5cHRHZW5SYW5kb20=').decode(),\n" +
            "    base64.b64decode(b'SW50ZXJuZXRPcGVuQQ==').decode(),\n" +
            "    base64.b64decode(b'SHR0cFNlbmRSZXF1ZXN0QQ==').decode(),\n" +
            "    base64.b64decode(b'WndDcmVhdGVTZWN0aW9u').decode()\n" +
            "]\n",

            "# === suspicious C2 domains (benign, not executed) ================================================\n" +
            "C2_DOMAINS = [\n" +
            "    base64.b64decode(b'bWFsd2FyZS1jMi5jb20=').decode(),\n" +
            "    base64.b64decode(b'ZXZpbC1zZXJ2ZXIubmV0').decode(),\n" +
            "    base64.b64decode(b'YmFkYWN0b3Iub3Jn').decode(),\n" +
            "    base64.b64decode(b'bWFsaWNpb3VzLWhvc3QuaW5mbw==').decode(),\n" +
            "    base64.b64decode(b'bWFsd2FyZS1jb21tYW5kLWNvbnRyb2wuZXhhbXBsZQ==').decode(),\n" +
            "    base64.b64decode(b'dXBkYXRlLXNlcnZpY2UuYmFkZXhhbXBsZS5vcmc=').decode(),\n" +
            "    base64.b64decode(b'ZHJvcHBlci50ZXN0LWRvbWFpbi5pbnZhbGlk').decode(),\n" +
            "    base64.b64decode(b'YzIuYmVhY29uLmludmFsaWQ=').decode()\n" +
            "]\n",

            "# == suspicious C2 IPs (benign, not executed) =====================================================\n" +
            "C2_IPS = [\n" +
            "    base64.b64decode(b'MjAzLjAuMTEzLjQy').decode(),\n" +
            "    base64.b64decode(b'MTk4LjUxLjEwMC4yMw==').decode(),\n" +
            "    base64.b64decode(b'OTIuMC4yLjU1').decode()\n" +
            "]\n",

            "# === EICAR test string (standard antivirus test) =================================================\n" +
            "EICAR_PLAIN = r'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'\n" +
            "EICAR_BASE64 = \"WDVPKVAlQVBbNFxQWlg1NChQXikyQ0MpN30kRUlDQVItU1RBTkRBUkQtQU5USVZJUlVTLVRFU1QtRklMRSFkSCtIKg==\"\n" +
            "\n" +
            "eicar_bytes = EICAR_PLAIN.encode()\n" +
            "eicar_gzipped = BytesIO()\n" +
            "with gzip.GzipFile(fileobj=eicar_gzipped, mode='wb') as gz:\n" +
            "    gz.write(eicar_bytes)\n" +
            "EICAR_GZ = base64.b64encode(eicar_gzipped.getvalue()).decode()\n",

            "# === fake shellcode patterns (hex bytes that look suspicious) ====================================\n" +
            "SHELLCODE = bytes([0x90, 0x90, 0x90, 0x90, 0x31, 0xc0, 0x50, 0x68])  # NOP sled + common opcodes\n",

            "# === suspicious powershell command ===============================================================\n" +
            "POWERSHELL = base64.b64decode(b'cG93ZXJzaGVsbCAtZW5j').decode()\n",

            "# === base64 markers ==============================================================================\n" +
            "BASE64_MARKER = base64.b64decode(b'QUFBQUFBQUE9PQ==').decode()\n",

            "# === suspicious executables ======================================================================\n" +
            "SUSPICIOUS_FILENAMES = [\n" +
            "    base64.b64decode(b'c3ZjaG9zdC5leGU=').decode(),\n" +
            "    base64.b64decode(b'dGFza2hvc3R3LmV4ZQ==').decode(),\n" +
            "    base64.b64decode(b'cnVuZGxsMzIuZXhl').decode(),\n" +
            "    base64.b64decode(b'ZXhwbG9yZXIuZXhl').decode()\n" +
            "]\n",

            "# === registry keys ===============================================================================\n" +
            "AUTORUN_REG_KEYS = [\n" +
            "    base64.b64decode(b'SEtDVVxcU29mdHdhcmVcXE1pY3Jvc29mdFxcd2luZG93c1xcQ3VycmVudFZlcnNpb25cXFJ1bg==').decode(),\n" +
            "    base64.b64decode(b'SEtMTVxcU29mdHdhcmVcXE1pY3Jvc29mdFxcd2luZG93c1xcQ3VycmVudFZlcnNpb25cXFJ1bg==').decode(),\n" +
            "    base64.b64decode(b'SEtMTVxcU09GVFdBUkVcXE1pY3Jvc29mdFxcd2luZG93cyBOVFxcd2luZGxvZ2luXFxTaGVsbA==').decode()\n" +
            "]\n",

            "# === mutex names =================================================================================\n" +
            "MUTEX_NAMES = [\n" +
            "    base64.b64decode(b'R2xvYmFsXFxTT01FX1NVU1BJQ0lPVVNfTVVURVg=').decode(),\n" +
            "    base64.b64decode(b'TGxvYmFsXFxSQU5TT01fTE9DSw==').decode(),\n" +
            "    base64.b64decode(b'V2luUmluZzBfMV8yXzA=').decode()\n" +
            "]\n",

            "# === packer indicators ===========================================================================\n" +
            "UPX_MARKERS = [\n" +
            "    base64.b64decode(b'VVBYIQ==').decode(),\n" +
            "    base64.b64decode(b'LlVQWDA=').decode(),\n" +
            "    base64.b64decode(b'LlVQWDE=').decode()\n" +
            "]\n" +
            "\n" +
            "OTHER_PACKERS = [\n" +
            "    base64.b64decode(b'QVNQYWNr').decode(),\n" +
            "    base64.b64decode(b'RlNHIQ==').decode(),\n" +
            "    base64.b64decode(b'UEV0aXRl').decode(),\n" +
            "    base64.b64decode(b'VGhlbWlkYQ==').decode(),\n" +
            "    base64.b64decode(b'Vk1Qcm90ZWN0').decode()\n" +
            "]\n",

            "# === ransom note =================================================================================\n" +
            "FAKE_RANSOM_NOTE = base64.b64decode(\n" +
            "    b'KiogQkVOSUdOIFRFU1QgTk9URSAqKgpZb3VyIGZpbGVzIGhhc2UgYmVlbiBlbmNyeXB0ZWQhClNlbmQgMTAwMCBCaXRjb2lucyB0byB0aGUgZm9sbG93aW5nIGFkZHJlc3M6IDFGYWtlUmFuc29tQWRkck5vVmFsaWRDaGVja3N1bTEyMzQ1Njc4OSAKU2VuZCBjb25maXJtYXRpb24gdG8gZXZpbEBoYWNrZXIuY29tCg=='\n" +
            ").decode()\n",

            "# === high entropy blob ============================================================================\n" +
            "HIGH_ENTROPY_BLOB = (\n" +
            "    \"IF9kYXRhX2ZpbGxlcl9iZW5pZ25f\" * 500\n" +
            ")\n",

            "# === pdb/build path (string only) ================================================================\n" +
            "PDB_PATH = base64.b64decode(b'QzpcXGJ1aWxkc1xtYWx3YXJlLWxhYlxccGF5bG9hZFxyZWxlYXNlXHBheWxvYWQucGRi').decode()\n" +
            "OTHER_PDB = base64.b64decode(b'RDpcXFByb2plY3RzXFJSQVRcXERlYnVnXHJhdC5wZGI=').decode()\n",

            "# === family name tokens used by generic rules (string only) ======================================\n" +
            "FAMILY_MARKERS = [\n" +
            "    base64.b64decode(b'd2FubmFjcnk=').decode(),\n" +
            "    base64.b64decode(b'ZW1vdGV0').decode(),\n" +
            "    base64.b64decode(b'dHJpY2tib3Q=').decode(),\n" +
            "    base64.b64decode(b'cWFrYm90').decode(),\n" +
            "    base64.b64decode(b'YWdlbnR0ZXNsYQ==').decode(),\n" +
            "    base64.b64decode(b'cmVtY29z').decode(),\n" +
            "    base64.b64decode(b'bmFub2NvcmU=').decode(),\n" +
            "    base64.b64decode(b'bG9raWJvdA==').decode()\n" +
            "]\n"
        ],
        "functions": [
            "# === crypto functions ============================================================================\n" +
            "def xor_encrypt(data, key):\n" +
            "    \"\"\" simple XOR encryption \"\"\"\n" +
            "    result = []\n" +
            "    for i, byte in enumerate(data):\n" +
            "        result.append(byte ^ key[i % len(key)])\n" +
            "    return bytes(result)\n",

            "def encrypt(data: str = base64.b64decode(b'dGhpcyBpcyBzZWNyZXQgZGF0YQ=='), password : str = base64.b64decode(b'dGhpcwBpcyBteSBzZWNyZXQga2V5')):\n" +
            "    encrypted = xor_encrypt(data, password)\n" +
            "    ransom_msg = base64.b64decode(b'RW5jcnlwdGVkIHlvdXIgZGlyZWN0b3J5IGFuZCBhbGwgb3VyIGZpbGVzLCBlbWFpbCBoYWNrZXJAZXZpbC1jb3JwLmNvbSBmb3IgcmFuc29tOg==').decode()\n" +
            "    print(f\"{ransom_msg} {encrypted.hex()}\")\n" +
            "    return encrypted\n",

            "def aes256_encrypt(input_file, output_file, password):\n" +
            "    \"\"\" encrypt a file using AES-256 \"\"\"\n" +
            "    salt = os.urandom(16)\n" +
            "    key = PBKDF2HMAC(\n" +
            "        algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000\n" +
            "    ).derive(password.encode())\n" +
            "    iv = os.urandom(16)\n" +
            "    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))\n" +
            "    encryptor = cipher.encryptor()\n" +
            "    with open(input_file, 'rb') as infile, open(output_file, 'wb') as outfile:\n" +
            "        outfile.write(salt + iv)\n" +
            "        data = infile.read()\n" +
            "        pad_len = 16 - (len(data) % 16)\n" +
            "        data += bytes([pad_len] * pad_len)\n" +
            "        outfile.write(encryptor.update(data) + encryptor.finalize())\n" +
            "    print(f\"File encrypted: {input_file} -> {output_file}\")\n" +
            "    return True\n",

            "# === virtual machine checks ======================================================================\n" +
            "def check_vm_artifacts():\n" +
            "    \"\"\" check for virtualization artifacts \"\"\"\n" +
            "    vm_indicators = [\n" +
            "        base64.b64decode(b'Vk13YXJl').decode(),\n" +
            "        base64.b64decode(b'VmlydHVhbEJveA==').decode(),\n" +
            "        base64.b64decode(b'VkJPWA==').decode(),\n" +
            "        base64.b64decode(b'UVFNVQ==').decode(),\n" +
            "        base64.b64decode(b'WGVu').decode(),\n" +
            "        base64.b64decode(b'SHlwbGVyLVY=').decode(),\n" +
            "        base64.b64decode(b'UGFyYWxsZWxz').decode(),\n" +
            "        base64.b64decode(b'VmlydHVhbCBNYWNoaW5l').decode()\n" +
            "    ]\n" +
            "    for indicator in vm_indicators:\n" +
            "    # Control flow alteration: obfuscated VM indicator check\n" +
            "            platform_str = str(sys.platform).lower()\n" +
            "            ind = indicator.lower()\n" +
            "            if any([ind in platform_str[::-1][::-1], platform_str.find(ind) != -1, ''.join(reversed(ind)) in platform_str]):\n" +
            "                print(f\"[VM Detection] Found: {indicator}\")\n" +
            "                return True\n" +
            "    return False\n",

            "# === network beacon simulator ====================================================================\n" +
            "def network_beacon():\n" +
            "    \"\"\" simulate network beacon behavior \"\"\"\n" +
            "    try:\n" +
            "        # Simulate C2 communication attempt\n" +
            "        for domain in C2_DOMAINS[:2]:\n" +
            "            try:\n" +
            "                socket.gethostbyname(domain)  # DNS lookup\n" +
            "                print(f\"[Network] Beacon to {domain}\")\n" +
            "            except:\n" +
            "                pass\n" +
            "    except:\n" +
            "        pass\n"
            "# === network beacon simulator ====================================================================\n" +
            "def network_beacon():\n" +
            "    \"\"\" simulate network beacon behavior \"\"\"\n" +
            "    try:\n" +
            "        # Simulate C2 communication attempt\n" +
            "        for domain in C2_DOMAINS[:2]:\n" +
            "            try:\n" +
            "                socket.gethostbyname(domain)  # DNS lookup\n" +
            "                print(f\"[Network] Beacon to {domain}\")\n" +
            "            except:\n" +
            "                pass\n" +
            "    except:\n" +
            "        pass\n",

            "# === hash calculator =========================================================================\n" +
            "def get_sha256(executable_path):\n" +
            "    try:\n" +
            "        # Calculate the SHA-256 hash\n" +
            "        sha256_hash = hashlib.sha256()\n" +
            "        with open(executable_path, 'rb') as f:\n" +
            "            # Read and update hash in chunks for memory efficiency\n" +
            "            for byte_block in iter(lambda: f.read(4096), b\"\"):\n" +
            "                sha256_hash.update(byte_block)\n" +
            "        \n" +
            "        return sha256_hash.hexdigest()\n" +
            "    except Exception as e:\n" +
            "        print(f\"Error calculating SHA-256 hash: {e}\", file=sys.stderr)\n" +
            "        return None\n",

            "# === file writer ===========================================================================\n" +
            "def write_to_file(filename, content):\n" +
            "    try:\n" +
            "        with open(filename, 'a', encoding='utf-8') as file:\n" +
            "            file.write(f\"{content}\\n\")\n" +
            "    except IOError as ioException:\n" +
            "        print(f\"Error writing to file: {ioException}\", file=sys.stderr)\n" +
            "    except Exception as exception:\n" +
            "        print(f\"Unexpected error: {exception}\", file=sys.stderr)\n"
        ],
        "main": (
            "# =================================================================================================\n"
            "def main():\n"
            "    print(\"----------------------------- Obfuscation Test Sample -----------------------------\")\n"
            "    print(\"[-] Base Implementation -----------------------------------------------------------\")\n"
            "    print(\"[-] Instruction Substitution ------------------------------------------------------\")\n"
            "    print(\"[-] String Encoding ---------------------------------------------------------------\")\n"
            "    print(\"[-] Control Flow Alteration -------------------------------------------------------\")\n"
            "    print(\"[-] Packed using UPX --------------------------------------------------------------\")\n"
            "    print(\"[-] Metamorphic -------------------------------------------------------------------\")\n"
            "\n") +
            "    hash = globals()[chr(103)+chr(101)+chr(116)+chr(95)+chr(115)+chr(104)+chr(97)+chr(50)+chr(53)+chr(54)](sys.executable)\n" +
            "    encrypt()\n" +
            "    vm_detected = check_vm_artifacts()\n" +
            "\n" +
            "    file_name = \"obfuscation-v7.bin\"\n" +
            "    for index in range(10):\n" +
            "        time.sleep(0.100)\n" +
            "\n" +
            "        # Control flow alteration: obfuscated conditional (executes for index == 5)\n" +
            "        if ((index * 2) ^ 0xA) == 0:\n" +
            "            globals()[chr(119)+chr(114)+chr(105)+chr(116)+chr(101)+chr(95)+chr(116)+chr(111)+chr(95)+chr(102)+chr(105)+chr(108)+chr(101)](file_name, hash)\n" +
            "\n" +
            "            globals()[chr(119)+chr(114)+chr(105)+chr(116)+chr(101)+chr(95)+chr(116)+chr(111)+chr(95)+chr(102)+chr(105)+chr(108)+chr(101)](file_name, EICAR_PLAIN)\n" +
            "            globals()[chr(119)+chr(114)+chr(105)+chr(116)+chr(101)+chr(95)+chr(116)+chr(111)+chr(95)+chr(102)+chr(105)+chr(108)+chr(101)](file_name, EICAR_GZ)\n" +
            "            globals()[chr(119)+chr(114)+chr(105)+chr(116)+chr(101)+chr(95)+chr(116)+chr(111)+chr(95)+chr(102)+chr(105)+chr(108)+chr(101)](file_name, SHELLCODE)\n" +
            "\n" +
            "            crypto_data = f\"Key: {secrets.token_hex(16)}\\n\"\n" +
            "            crypto_data += f\"IV: {secrets.token_hex(8)}\\n\"\n" +
            "            globals()[chr(119)+chr(114)+chr(105)+chr(116)+chr(101)+chr(95)+chr(116)+chr(111)+chr(95)+chr(102)+chr(105)+chr(108)+chr(101)](file_name, crypto_data)\n" +
            "\n" +
            "            network_beacon()\n" +
            "\n" +
            "        suspicious_call = f\"Calling {SUSPICIOUS_API_CALLS[index % len(SUSPICIOUS_API_CALLS)]}\"\n" +
            "        print(f\"[{index}] {suspicious_call}\")\n" +
            "\n" +
            "    print(\"\\n------------------------------------------------------------------------------------\")\n" +
            "    \n",
        "entry": "if __name__ == \"__main__\":\n" +
            "    main()\n"
    }
    return logic_blocks

if __name__ == "__main__":
    engine = metamorphic_engine()
    logic_blocks = get_logic_blocks()
    engine.generate_variant(logic_blocks)
    
# inspired by https://spyboy.blog/2025/05/03/metamorphic-programming-building-a-self-modifying-code-engine-in-python/

# pyinstaller .\malware\obfuscation-v7.py --onefile --distpath .\dist\rq1\