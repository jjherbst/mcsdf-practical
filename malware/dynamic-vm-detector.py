"""dynamic-vm-detector.py
=================================
Purpose:
    Demonstrate multi‑layer virtual machine / sandbox environment detection techniques
    commonly (ab)used by real-world malware for dynamic analysis evasion. This sample
    aggregates several orthogonal heuristics so you can observe which trigger inside
    your lab environment. It is intentionally transparent (no packing / obfuscation)
    and performs only a benign payload if no VM indicators are found.

DISCLAIMER:
    This code is provided strictly for academic / defensive research. Do NOT embed
    these techniques in offensive tooling. Many individual checks are noisy or
    susceptible to false positives; production-grade samples often gate execution or
    add timing / anti-debug layers on top. Here we keep everything simple and readable.

Detection Surface Covered:
    1. Process Enumeration      (guest tools / services)
    2. Filesystem Artifacts     (drivers, additions, app bundles)
    3. CPUID Hypervisor Bit     (architectural indicator)
    4. MAC Address OUI Prefix   (virtual NIC vendors)
    5. Windows Registry Values  (firmware / device identifiers)

Design Notes:
    * Each check returns a boolean and prints the specific indicator when detected.
    * The master function `is_virtualized()` aggregates results with OR semantics.
    * Failure / unsupported platform conditions degrade gracefully (return False).
    * No attempt is made to hide behavior; code favors clarity for study.
"""

import sys
import os
import platform
import ctypes
import time
import hashlib

try:  # psutil provides cross‑platform process & network interface enumeration
    import psutil
except ImportError:  # Hard fail early so later checks don't partially work
    print("psutil is required for process & MAC checks. Install with 'pip install psutil'.")
    sys.exit(1)

def check_vm_processes():
    """Detect hypervisor / guest enrichment processes.

    Looks for canonical binary names associated with installed guest additions
    or virtualization support services. Presence usually implies execution inside
    a managed VM. Easily bypassed if analyst renames binaries or disables tools.
    """
    vm_processes = [
        'vboxservice.exe', 'vboxtray.exe',  # VirtualBox
        'vmtoolsd.exe', 'vmwaretray.exe', 'vmwareuser.exe',  # VMware
        'vgauthservice.exe', 'vgtray.exe',   # VMware
        'qemu-ga.exe',                       # QEMU
        'xensource-windows-guest-agent.exe'  # Xen
    ]
    target_set = {p.lower() for p in vm_processes}
    # Iterate with minimal attributes for performance / reduced permission needs
    for proc in psutil.process_iter(['name']):
        name = (proc.info.get('name') or '').lower()
        if name in target_set:
            print(f"Detected VM process: {proc.info['name']}")
            return True  # Short‑circuit on first positive
    return False

def check_vm_files():
    """Detect well-known virtualization filesystem artifacts.

    Includes driver filenames, guest addition executables and Linux / macOS paths.
    Absence does NOT guarantee bare-metal; analysts can remove or relocate them.
    """
    vm_files = [
        '/Applications/VirtualBox.app',                    # macOS VirtualBox
        '/Applications/VMware Fusion.app',                 # macOS VMware
        '/proc/xen', '/proc/scsi/scsi',                    # Linux VM indicators
        'C:\\windows\\System32\\Drivers\\Vmmouse.sys',     # Windows VMware
        'C:\\windows\\System32\\Drivers\\VBoxMouse.sys',   # Windows VirtualBox
        'C:\\windows\\System32\\Drivers\\VBoxGuest.sys',   # VirtualBox Guest Additions
        'C:\\windows\\System32\\Drivers\\VBoxSF.sys',      # VirtualBox Shared Folders
        'C:\\windows\\System32\\VBoxService.exe',          # VirtualBox Service
        'C:\\windows\\System32\\VBoxTray.exe',             # VirtualBox Tray
        'C:\\Program Files\\Oracle\\VirtualBox Guest Additions\\VBoxControl.exe'  # VBox Control
    ]
    found = False
    for file_path in vm_files:
        if os.path.exists(file_path):
            print(f"Detected VM file: {file_path}")
            found = True
    return found

def check_hypervisor_cpuid():
    """Inspect CPUID leaf 0x1 ECX[31] hypervisor bit on x86/x64.

    If set, indicates the processor is under a hypervisor abstraction layer.
    Some advanced hypervisors may mask this; some nested virtualization setups
    still expose it. Not applicable on ARM / other architectures.
    """
    if platform.machine() not in ('i386', 'x86_64', 'AMD64'):
        return False  # Not applicable on non-x86
    try:
        # Define a minimal structure to hold register outputs
        class CPUID(ctypes.Structure):
            _fields_ = [('eax', ctypes.c_uint32),
                        ('ebx', ctypes.c_uint32),
                        ('ecx', ctypes.c_uint32),
                        ('edx', ctypes.c_uint32)]

        def cpuid(fn):
            # Raw machine code stub performing CPUID while preserving RBX
            buf = CPUID()
            asm = (
                b'\x53'  # push rbx
                b'\x48\x89\xd3'  # mov rbx, rdx (for *nix)
                b'\x0f\xa2'  # cpuid
                b'\x5b'  # pop rbx
            )
            # Make memory executable (Windows specific). On *nix we'd mmap.
            ctypes.windll.kernel32.VirtualProtect(asm, len(asm), 0x40, ctypes.byref(ctypes.c_ulong()))
            func = ctypes.cast(asm, ctypes.CFUNCTYPE(None, ctypes.c_uint32, ctypes.POINTER(CPUID)))
            func(fn, ctypes.byref(buf))
            return buf

        leaf = cpuid(0x1)
        if leaf.ecx & (1 << 31):  # Hypervisor bit in ECX
            print("Hypervisor bit detected in CPUID.")
            return True
    except Exception:
        # Silently ignore (insufficient privileges, unsupported OS, DEP issues, etc.)
        pass
    return False

def check_mac_address():
    """Match first three bytes (OUI) of NIC MAC address against VM vendor list.

    NOTE: Interface name 'Ethernet' is Windows‑centric; production code would
    iterate all interfaces. OUIs are spoofable and sometimes reused by clouds.
    """
    try:
        # psutil returns list of snicaddr; we want the MAC address string
        # Simplify by targeting a common interface label; adapt for other OS.
        mac = psutil.net_if_addrs()['Ethernet'][0].address  # e.g. '08:00:27:12:34:56'
        vm_ouis = ['00:05:69', '00:0c:29', '00:1c:14', '00:50:56',  # VMware
                   '08:00:27',  # VirtualBox
                   '52:54:00']  # QEMU/KVM
        if mac[:8].lower() in [oui.lower() for oui in vm_ouis]:
            print(f"Detected VM MAC OUI: {mac[:8]}")
            return True
    except Exception:
        pass
    return False

def check_vm_registry():
    """Check Windows registry firmware / device strings for virtualization tokens.

    Keys chosen surface BIOS / video BIOS / disk identifiers which frequently
    embed vendor strings (e.g., 'VBOX', 'VMware'). Only executed on Windows.
    """
    if platform.system() != 'Windows':
        return False
    
    try:
        import winreg
        vm_registry_keys = [  # (Hive, KeyPath, ValueName)
            (winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System", "SystemBiosVersion"),
            (winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DESCRIPTION\System", "VideoBiosVersion"),
            (winreg.HKEY_LOCAL_MACHINE, r"HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0", "Identifier"),
            (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\ControlSet001\Services\Disk\Enum", "0")
        ]

        vm_indicators = [  # Lower‑case tokens to match anywhere in value string
            'vbox', 'virtualbox', 'oracle', 'innotek',  # VirtualBox
            'vmware', 'vmxh',                           # VMware
            'qemu', 'bochs', 'xen'                      # Other VMs
        ]

        found = False
        for hkey, key_path, value_name in vm_registry_keys:
            try:
                with winreg.OpenKey(hkey, key_path) as key:
                    value, _ = winreg.QueryValueEx(key, value_name)
                    if any(indicator.lower() in str(value).lower() for indicator in vm_indicators):
                        print(f"Detected VM registry indicator: {value}")
                        found = True
            except (WindowsError, FileNotFoundError):  # Key or value not present
                continue

    except ImportError:
        pass  # winreg not available (non‑Windows Python build)
    except Exception:
        pass  # Suppress unexpected parsing errors
        
    return found

def is_virtualized():
    """Aggregate all heuristics.

    Returns:
        bool: True if any single detection primitive reports a positive.

    Rationale:
        Using OR semantics reduces false negatives (better coverage) at the cost
        of potential false positives in exotic hardware / custom setups. A more
        conservative approach would require a threshold (e.g., >= N indicators).
    """
    checks = [
        check_vm_processes(),
        check_vm_files(),
        check_hypervisor_cpuid(),
        check_mac_address(),
        check_vm_registry()
    ]
    return any(checks)

def print_hash():
    if getattr(sys, 'frozen', False):
        target = sys.executable
    else:
        target = os.path.abspath(__file__)
    hasher = hashlib.sha256()
    try:
        with open(target, 'rb') as f:
            for chunk in iter(lambda: f.read(8192), b''):
                hasher.update(chunk)
        digest = hasher.hexdigest()
        print(f"[hash] SHA256 {digest} (file={os.path.basename(target)})")
        return digest
    except OSError as e:
        print(f"[hash] Error hashing file: {e}")
        return None

def drop_benign_payload():
    print("No virtualization detected.")
    print("Benign payload executed.")
        
if __name__ == "__main__":
    print("----------------------------- Sandbox Detection Loop Started------------------------------")
    print_hash()
    
    while True:
        if is_virtualized() == True:
            print("Virtualized environment detected! Exiting to evade analysis.")
            break
        else:
            drop_benign_payload()
    
    print("---------------------------- Sandbox Detection Loop Finished -----------------------------")